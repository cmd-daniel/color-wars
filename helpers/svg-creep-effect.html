<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>SVG Blob Growth</title>
    <style>
      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #111;
        color: #ddd;
        font-family: sans-serif;
        gap: 10px;
        padding: 10px;
      }
      canvas {
        border: 2px solid #444;
        background: #222;
        cursor: crosshair;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      input[type="range"],
      input[type="number"] {
        width: 120px;
      }
      button {
        padding: 6px 12px;
        border-radius: 4px;
        border: none;
        background: #444;
        color: #eee;
        cursor: pointer;
      }
      button.primary {
        background: #2ea85a;
      }
    </style>
  </head>
  <body>
    <input type="file" id="svgFile" accept=".svg" />
    <div class="controls">
      <label>Cell Size: <input type="number" id="cellSize" value="2" min="2" /></label>
      <label>Speed: <input type="range" id="speedSlider" min="1" max="50" value="50" /></label>
      <label
        >Wall Width: <input type="range" id="wallWidthSlider" min="1" max="20" value="2"
      /></label>
      <button id="startBtn" class="primary">Start</button>
      <button id="resetBtn">Reset</button>
    </div>
    <canvas id="canvas" width="500" height="400"></canvas>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const cellSizeInput = document.getElementById("cellSize");
      const speedSlider = document.getElementById("speedSlider");
      const wallWidthSlider = document.getElementById("wallWidthSlider");
      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const svgFileInput = document.getElementById("svgFile");

      let cellSize = parseInt(cellSizeInput.value);
      let cols = Math.floor(canvas.width / cellSize);
      let rows = Math.floor(canvas.height / cellSize);

      let mask = [];
      let visited = [];
      let queue = [];
      let running = false;
      let animationId = null;
      let drawingWall = false;

      // Auto-color array for seeds
      const colors = ["#2ea85a", "#e63946", "#f1fa3c", "#4361ee", "#ff9f1c", "#9d4edd"];
      let colorIndex = 0;

      // Initialize grid
      function initGrid() {
        cols = Math.floor(canvas.width / cellSize);
        rows = Math.floor(canvas.height / cellSize);
        mask = Array.from({ length: rows }, () => Array(cols).fill(true));
        visited = Array.from({ length: rows }, () => Array(cols).fill(null));
        queue = [];
        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Draw walls
      function drawWalls() {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (!mask[r][c]) {
              ctx.fillStyle = "#555";
              ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
            }
          }
        }
      }

      // Draw wall cells with wallWidth
      function drawWallsFromSVGPoint(r, c) {
        const wallWidth = parseInt(wallWidthSlider.value);
        for (let dr = 0; dr < wallWidth; dr++) {
          for (let dc = 0; dc < wallWidth; dc++) {
            const nr = r + dr;
            const nc = c + dc;
            if (nr >= 0 && nc >= 0 && nr < rows && nc < cols) {
              mask[nr][nc] = false;
            }
          }
        }
      }

      // Shuffle helper
      function shuffle(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
        return array;
      }

      // Draw a blob cell
      function drawCell(r, c, color) {
        ctx.fillStyle = color;
        ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
      }

      // BFS step
      function stepOnce() {
        const perFrame = parseInt(speedSlider.value);
        let popped = 0;
        while (popped < perFrame && queue.length > 0) {
          const seed = queue.shift();
          const { r, c, color } = seed;
          drawCell(r, c, color);

          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
            [1, 1],
            [-1, 1],
            [1, -1],
            [-1, -1],
          ];
          shuffle(dirs).forEach(([dr, dc]) => {
            const nr = r + dr,
              nc = c + dc;
            if (nr < 0 || nc < 0 || nr >= rows || nc >= cols) return;
            if (!mask[nr][nc] || visited[nr][nc]) return;
            visited[nr][nc] = color;
            if (Math.random() < 0.5) queue.push({ r: nr, c: nc, color });
            else setTimeout(() => queue.push({ r: nr, c: nc, color }), Math.random() * 200);
          });
          popped++;
        }
      }

      // Animation loop
      function loop() {
        if (running) stepOnce();
        animationId = requestAnimationFrame(loop);
      }

      // Controls
      startBtn.addEventListener("click", () => {
        if (queue.length === 0) {
          alert("Add at least one seed (right-click) before starting!");
          return;
        }
        running = !running;
        startBtn.textContent = running ? "Pause" : "Start";
        if (!animationId) {
          // start loop only once
          loop();
        }
      });

      resetBtn.addEventListener("click", () => {
        running = false;
        startBtn.textContent = "Start";
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        queue = [];
        visited = Array.from({ length: rows }, () => Array(cols).fill(null));
        colorIndex = 0;
        initGrid();
        drawWalls();
      });

      // Cell size change
      cellSizeInput.addEventListener("change", () => {
        cellSize = parseInt(cellSizeInput.value);
        initGrid();
        drawWalls();
      });

      // Mouse events
      canvas.addEventListener("mousedown", (e) => {
        const x = e.offsetX;
        const y = e.offsetY;
        const c = Math.floor(x / cellSize);
        const r = Math.floor(y / cellSize);

        if (e.button === 0) {
          // left-click = draw walls
          drawingWall = true;
          mask[r][c] = false;
          drawWalls();
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!drawingWall) return;
        const x = e.offsetX;
        const y = e.offsetY;
        const c = Math.floor(x / cellSize);
        const r = Math.floor(y / cellSize);
        if (r >= 0 && c >= 0 && r < rows && c < cols) {
          mask[r][c] = false;
          drawWalls();
        }
      });

      canvas.addEventListener("mouseup", () => {
        drawingWall = false;
      });

      // Right-click = add seeds with auto-color
      canvas.addEventListener("contextmenu", (e) => e.preventDefault());
      canvas.addEventListener("mousedown", (e) => {
        if (e.button === 2) {
          const x = e.offsetX;
          const y = e.offsetY;
          const c = Math.floor(x / cellSize);
          const r = Math.floor(y / cellSize);
          if (r < 0 || c < 0 || r >= rows || c >= cols) return;
          if (mask[r][c] && !visited[r][c]) {
            const color = colors[colorIndex];
            colorIndex = (colorIndex + 1) % colors.length;
            visited[r][c] = color;
            queue.push({ r, c, color });
            drawCell(r, c, color);
          }
        }
      });

      // Upload SVG and convert paths to walls
      svgFileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
          const svgText = evt.target.result;
          initGrid();
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
          const paths = svgDoc.querySelectorAll("path");
          const svgEl = svgDoc.querySelector("svg");
          let vb = [0, 0, canvas.width, canvas.height];
          const viewBox = svgEl.getAttribute("viewBox");
          if (viewBox) vb = viewBox.split(" ").map(Number);
          const [minX, minY, vbWidth, vbHeight] = vb;
          const scaleX = canvas.width / vbWidth;
          const scaleY = canvas.height / vbHeight;

          paths.forEach((pathEl) => {
            const tempPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tempPath.setAttribute("d", pathEl.getAttribute("d"));
            const pathLength = tempPath.getTotalLength();
            for (let i = 0; i <= pathLength; i += 1) {
              // sample every 1px
              const pt = tempPath.getPointAtLength(i);
              const px = (pt.x - minX) * scaleX;
              const py = (pt.y - minY) * scaleY;
              const c = Math.floor(px / cellSize);
              const r = Math.floor(py / cellSize);
              drawWallsFromSVGPoint(r, c); // apply wall width
            }
          });
          drawWalls();
        };
        reader.readAsText(file);
      });
    </script>
  </body>
</html>
