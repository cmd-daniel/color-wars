<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Axial Hex Blob Growth</title>
    <style>
      body {
        margin: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #111;
        color: #ddd;
        font-family: sans-serif;
        gap: 10px;
        padding: 10px;
      }
      canvas {
        border: 2px solid #444;
        background: #222;
        cursor: crosshair;
      }
      .controls {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      input[type="range"],
      input[type="number"] {
        width: 120px;
      }
      button {
        padding: 6px 12px;
        border-radius: 4px;
        border: none;
        background: #444;
        color: #eee;
        cursor: pointer;
      }
      button.primary {
        background: #2ea85a;
      }
    </style>
  </head>
  <body>
    <input type="file" id="svgFile" accept=".svg" />
    <div class="controls">
      <label>Hex Size: <input type="number" id="cellSize" value="1" min="1" /></label>
      <label>Speed: <input type="range" id="speedSlider" min="1" max="500" value="50" /></label>
      <label
        >Wall Width: <input type="range" id="wallWidthSlider" min="1" max="5" value="1"
      /></label>
      <button id="startBtn" class="primary">Start</button>
      <button id="resetBtn">Reset</button>
    </div>
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
      const canvas = document.getElementById("canvas");

      canvas.width = window.innerWidth - 100;
      canvas.height = window.innerHeight - 100;

      window.addEventListener("resize", () => {
        canvas.width = window.innerWidth - 100;
        canvas.height = window.innerHeight - 100;
        drawTransformed(); // Redraw to fit new size
      });
      const ctx = canvas.getContext("2d");

      const cellSizeInput = document.getElementById("cellSize");
      const speedSlider = document.getElementById("speedSlider");
      const wallWidthSlider = document.getElementById("wallWidthSlider");
      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const svgFileInput = document.getElementById("svgFile");

      let cellSize = parseInt(cellSizeInput.value);
      let mask = {}; // key="q,r" => false if wall
      let visited = {}; // key="q,r" => color
      let hexByColor = {};
      let queue = [];
      let running = false;
      let animationId = null;
      let drawingWall = false;
      let colorIndex = 0;
      const colors = ["#2ea85a", "#e63946"];

      // Zoom & pan
      let scale = 1;
      let offsetX = 0;
      let offsetY = 0;
      let isPanning = false;
      let startPan = { x: 0, y: 0 };

      // Helpers
      function cellKey(q, r) {
        return `${q},${r}`;
      }

      function hexToPixel(q, r, size) {
        const x = size * Math.sqrt(3) * (q + r / 2);
        const y = ((size * 3) / 2) * r;
        return { x, y };
      }

      function pixelToHex(x, y, size) {
        const r = Math.round(y / ((size * 3) / 2));
        const q = Math.round(x / (size * Math.sqrt(3)) - r / 2);
        return { q, r };
      }

      function drawHex(ctx, q, r, size, color) {
        const { x, y } = hexToPixel(q, r, size);
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 180) * (60 * i - 30); // pointy-topped
          const px = x + size * Math.cos(angle);
          const py = y + size * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
      }

      // 6 axial neighbors
      const directions = [
        [+1, 0],
        [+1, -1],
        [0, -1],
        [-1, 0],
        [-1, +1],
        [0, +1],
      ];
      function getNeighbors(q, r) {
        return directions.map(([dq, dr]) => [q + dq, r + dr]);
      }

      function visitHex(q, r, color) {
        const key = cellKey(q, r);
        visited[key] = color;
        if (!hexByColor[color]) hexByColor[color] = new Set();
        hexByColor[color].add(key);
      }

      // âœ… FIXED drawTransformed
      function drawTransformed() {
        ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);

        const margin = 0;
        const pixelTL = { x: -offsetX / scale, y: -offsetY / scale };
        const pixelBR = {
          x: (canvas.width - offsetX) / scale,
          y: (canvas.height - offsetY) / scale,
        };

        const hexW = Math.sqrt(3) * cellSize;
        const hexH = 1.5 * cellSize;

        const minR = Math.floor(pixelTL.y / hexH) - margin;
        const maxR = Math.ceil(pixelBR.y / hexH) + 20;
        const minQ = Math.floor(pixelTL.x / hexW) - 2000;
        const maxQ = Math.ceil(pixelBR.x / hexW) + 20;

        for (let r = minR; r <= maxR; r++) {
          for (let q = minQ; q <= maxQ; q++) {
            const key = cellKey(q, r);
            const { x, y } = hexToPixel(q, r, cellSize);

            if (x + cellSize < pixelTL.x || x - cellSize > pixelBR.x) continue;
            if (y + cellSize < pixelTL.y || y - cellSize > pixelBR.y) continue;

            if (mask[key] === false) drawHex(ctx, q, r, cellSize, "#555");
            if (visited[key]) drawHex(ctx, q, r, cellSize, visited[key]);
          }
        }
      }

      // Draw walls
      function drawWallsFromPoint(q, r) {
        const wallWidth = parseInt(wallWidthSlider.value);
        for (let dr = 0; dr < wallWidth; dr++) {
          for (let dq = 0; dq < wallWidth; dq++) {
            const nq = q + dq,
              nr = r + dr;
            mask[cellKey(nq, nr)] = false;
          }
        }
      }

      // BFS step
      function stepOnce() {
        const perFrame = parseInt(speedSlider.value);
        let popped = 0;
        while (popped < perFrame && queue.length > 0) {
          const { q, r, color } = queue.shift();
          const key = cellKey(q, r);
          if (mask[key] === false || visited[key]) continue;
          visitHex(q, r, color);

          getNeighbors(q, r).forEach(([nq, nr]) => {
            const nKey = cellKey(nq, nr);
            if (mask[nKey] === false || visited[nKey]) return;
            if (Math.random() < 0.6) queue.push({ q: nq, r: nr, color });
            else
              setTimeout(() => {
                if (mask[nKey] !== false && !visited[nKey]) queue.push({ q: nq, r: nr, color });
              }, Math.random() * 200);
          });
          popped++;
        }
        drawTransformed();
      }

      // Animation loop
      function loop() {
        if (running) stepOnce();
        animationId = requestAnimationFrame(loop);
      }

      // Controls
      startBtn.addEventListener("click", () => {
        if (queue.length === 0) {
          alert("Add at least one seed (right-click) before starting!");
          return;
        }
        running = !running;
        startBtn.textContent = running ? "Pause" : "Start";
        if (!animationId) loop();
      });

      resetBtn.addEventListener("click", () => {
        running = false;
        startBtn.textContent = "Start";
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }
        queue = [];
        visited = {};
        hexByColor = {};
        mask = {};
        colorIndex = 0;
        drawTransformed();
      });

      cellSizeInput.addEventListener("change", () => {
        cellSize = parseInt(cellSizeInput.value);
        drawTransformed();
      });

      // Mouse events
      canvas.addEventListener("mousedown", (e) => {
        const { q, r } = pixelToHex(
          (e.offsetX - offsetX) / scale,
          (e.offsetY - offsetY) / scale,
          cellSize,
        );
        if (e.button === 0) {
          drawingWall = true;
          mask[cellKey(q, r)] = false;
          drawTransformed();
        }
        if (e.button === 2) {
          if (!visited[cellKey(q, r)] && mask[cellKey(q, r)] !== false) {
            const color = colors[colorIndex];
            colorIndex = (colorIndex + 1) % colors.length;
            queue.push({ q, r, color });
            drawTransformed();
          }
        }
        if (e.button === 1) {
          isPanning = true;
          startPan = { x: e.clientX - offsetX, y: e.clientY - offsetY };
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        const { q, r } = pixelToHex(
          (e.offsetX - offsetX) / scale,
          (e.offsetY - offsetY) / scale,
          cellSize,
        );
        if (drawingWall && e.buttons === 1) {
          mask[cellKey(q, r)] = false;
          drawTransformed();
        }
        if (isPanning) {
          offsetX = e.clientX - startPan.x;
          offsetY = e.clientY - startPan.y;
          drawTransformed();
        }
      });
      canvas.addEventListener("mouseup", () => {
        drawingWall = false;
        isPanning = false;
      });
      canvas.addEventListener("mouseleave", () => {
        drawingWall = false;
        isPanning = false;
      });
      canvas.addEventListener("contextmenu", (e) => e.preventDefault());

      // Zoom
      canvas.addEventListener(
        "wheel",
        (e) => {
          if (!e.ctrlKey) return;
          e.preventDefault();
          const zoomFactor = 1.05;
          const mouseX = e.offsetX;
          const mouseY = e.offsetY;
          const wx = (mouseX - offsetX) / scale;
          const wy = (mouseY - offsetY) / scale;
          scale = e.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor;
          offsetX = mouseX - wx * scale;
          offsetY = mouseY - wy * scale;
          drawTransformed();
        },
        { passive: false },
      );

      // Load SVG walls
      svgFileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (evt) => {
          const svgText = evt.target.result;
          const parser = new DOMParser();
          const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
          const paths = svgDoc.querySelectorAll("path");
          const svgEl = svgDoc.querySelector("svg");
          let vb = [0, 0, canvas.width, canvas.height];
          const viewBox = svgEl.getAttribute("viewBox");
          if (viewBox) vb = viewBox.split(" ").map(Number);
          const [minX, minY] = vb;

          paths.forEach((pathEl) => {
            const tempPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
            tempPath.setAttribute("d", pathEl.getAttribute("d"));
            const pathLength = tempPath.getTotalLength();
            const step = Math.max(1, cellSize / 2);
            for (let i = 0; i <= pathLength; i += step) {
              const pt = tempPath.getPointAtLength(i);
              const px = pt.x - minX;
              const py = pt.y - minY;
              const { q, r } = pixelToHex(px, py, cellSize);
              drawWallsFromPoint(q, r);
            }
          });
          drawTransformed();
        };
        reader.readAsText(file);
      });

      drawTransformed(); // initial render
    </script>
  </body>
</html>
