{"version":3,"file":"HelperTypes.js","sourceRoot":"","sources":["../../src/types/HelperTypes.ts"],"names":[],"mappings":"","sourcesContent":["import type { Definition, DefinitionType, PrimitiveType, RawPrimitiveType } from \"../annotations\";\nimport type { Schema } from \"../Schema\";\nimport type { ArraySchema } from \"./custom/ArraySchema\";\nimport type { CollectionSchema } from \"./custom/CollectionSchema\";\nimport type { MapSchema } from \"./custom/MapSchema\";\nimport type { SetSchema } from \"./custom/SetSchema\";\n\nexport type Constructor<T = {}> = new (...args: any[]) => T;\n\nexport interface Collection<K = any, V = any, IT = V> {\n    [Symbol.iterator](): IterableIterator<IT>;\n    forEach(callback: Function);\n    entries(): IterableIterator<[K, V]>;\n}\n\nexport type InferValueType<T extends DefinitionType> =\n    T extends \"string\" ? string\n    : T extends \"number\" ? number\n    : T extends \"int8\" ? number\n    : T extends \"uint8\" ? number\n    : T extends \"int16\" ? number\n    : T extends \"uint16\" ? number\n    : T extends \"int32\" ? number\n    : T extends \"uint32\" ? number\n    : T extends \"int64\" ? number\n    : T extends \"uint64\" ? number\n    : T extends \"float32\" ? number\n    : T extends \"float64\" ? number\n    : T extends \"boolean\" ? boolean\n\n    // Handle { type: ... } patterns\n    : T extends { type: infer ChildType extends Constructor } ? InstanceType<ChildType>\n    : T extends { type: Array<infer ChildType> } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n    : T extends { type: { map: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\n    : T extends { type: { set: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\n    : T extends { type: { collection: infer ChildType } } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\n    : T extends { type: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType] : ChildType) // TS ENUM\n\n    // Handle direct array patterns\n    : T extends Array<infer ChildType extends Constructor> ? InstanceType<ChildType>[]\n    : T extends Array<infer ChildType> ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n\n    // Handle collection object patterns\n    : T extends { array: infer ChildType extends Constructor } ? InstanceType<ChildType>[]\n    : T extends { array: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? ChildType[keyof ChildType][] : ChildType[]) // TS ENUM\n\n    : T extends { map: infer ChildType extends Constructor } ? MapSchema<InstanceType<ChildType>>\n    : T extends { map: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? MapSchema<ChildType[keyof ChildType]> : MapSchema<ChildType>) // TS ENUM\n\n    : T extends { set: infer ChildType extends Constructor } ? SetSchema<InstanceType<ChildType>>\n    : T extends { set: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? SetSchema<ChildType[keyof ChildType]> : SetSchema<ChildType>) // TS ENUM\n\n    : T extends { collection: infer ChildType extends Constructor } ? CollectionSchema<InstanceType<ChildType>>\n    : T extends { collection: infer ChildType } ? (ChildType extends Record<string | number, string | number> ? CollectionSchema<ChildType[keyof ChildType]> : CollectionSchema<ChildType>) // TS ENUM\n\n    // Handle direct types\n    : T extends Constructor ? InstanceType<T>\n    : T extends Record<string | number, string | number> ? T[keyof T] // TS ENUM\n    : T extends PrimitiveType ? T\n\n    : never;\n\nexport type InferSchemaInstanceType<T extends Definition> = {\n    [K in keyof T]: InferValueType<T[K]>\n} & Schema;\n\nexport type DefinedSchemaType<T extends Definition, P extends typeof Schema> = {\n    new (): InferSchemaInstanceType<T> & InstanceType<P>;\n} & typeof Schema;\n\nexport type NonFunctionProps<T> = Omit<T, {\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T]>;\n\nexport type NonFunctionPropNames<T> = {\n    [K in keyof T]: T[K] extends Function ? never : K\n}[keyof T];\n\nexport type NonFunctionNonPrimitivePropNames<T> = {\n    [K in keyof T]: T[K] extends Function\n        ? never\n        : T[K] extends number | string | boolean\n            ? never\n            : K\n}[keyof T];\n\nexport type ToJSON<T> = NonFunctionProps<{\n    [K in keyof T]: T[K] extends MapSchema<infer U>\n        ? Record<string, U>\n        : T[K] extends Map<string, infer U>\n            ? Record<string, U>\n            : T[K] extends ArraySchema<infer U>\n                ? U[]\n                : T[K]\n}>;"]}